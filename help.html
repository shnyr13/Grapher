<html></html>
<html>
<head>
<title>Справка Grapher</title>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
</head>

<body>

	<h4><a href="#first">Введение</a></h4><br>
	<a href="#modes">1. Режимы работы</a><br>	
	<a href="#add_top_mode">1.1    Режим добавления вершин</a><br>
	<a href="#add_edge_mode">1.2    Режим добавления рёбер</a><br>
	<a href="#remove_mode">1.3   Режим удаления</a></h5><br>
	<a href="#see_edit_mode">1.4   Режим просмотра и редактирования</a><br>
	<a href="#save">Сохранение в файл</a><br>
	<a href="#load">Загрузка из файла</a><br>
	<a href="#ect">Дополнительные возможности</a></h4><br>
	
	
	<h4><a name="first">Введение</a></h4><br>
	Программа предназначена для построения и редактирования графов. Основными элементами главного окна является панель кнопок переключения режимаов (слева), панель изменения параметров вершин и рёбер (появляются в режиме просмотра и редактирования при выделении одного соотвтествующего элемента, находится слева).
	Основную часть окна программы занимает поле для графического ввода графа.
	<p>
		<h4><a name="modes">Режимы работы</a></h4>
		Для изменения режима работы служит левая панель, состоящая из четрёх кнопок.
		Если кнопка неактивна, то это признак соотвествующего режима.
		<img src="pointer.png">
		<h4><a name="add_top_mode">1.1   Режим добавления вершин</a></h4>
		Для перехода в режим добавления вершин, необходимо нажать кнопку <img src="circle.png"> или выбрать соответствующий пункт в меню <b>"Правка"</b>
		Для добавления вернины необходимо кликнуть в обрасть грфческого ввода, расположенного в основной части окна программы.
		<h4><a name="add_edge_mode">1.2   Режим добавления рёбер</a></h4>
		Для перехода в режим добавления рёбер необходимо нажать кнопку <img src="line-starts-with-arrow.png"> или выбрать соответствующий пункт в меню <b>"Правка"</b>
		Для давбавления ребра необходимо выбрать первую вершину (нажать левой кнопкой мыши), затем вторую.
		Если ребро можду этими вершинами уже существует, то выводится соотвтествующая ошибка (в таком случае, добавлине ребра невозможно).
		<h4><a name="remove_mode">1.3   Режим удаления</a></h5>
		Для перехода в режим удаления необходимо нажать кнопку <img src="pencil.png"> или выбрать соответствующий пункт в меню <b>"Правка"</b>
		Для того, чтобы удалить ребро или вершину, его/её необходиом выбрать (нажать левой кнопкой мыши).
		Обратите внимание на то, что при удалении вершины, удаляются все рёбра, которые с ней соединены.
		<h4><a name="see_edit_mode">1.4   Режим просмотра и редактирования</a></h4>
		Для перехода в режим просмотра и редактировнаия необходимо нажать кнопку <img src="pointer.png"> или выбрать соответствующий пункт в меню <b>"Правка"</b>
		В режиме просмотра и редактирования можно перетаскивать вершины, изменять цвет <b>выделенных</b> вершин и рёбер, нажав на квадрат, расположенный ниже четырёх кнопок переключения режимов.
		При выборе одного ребра (дуги) можно изменять его тип (ненапрвленная, однонаправленная, двунаправленная), перенаправлять ребро (если она однонаправленная), задавать веса рёбер.
		При выборе одной вершины можно менять ещё форму (круг, ромб, квадрат, треугольник), задавать имя вершины (которое будет всплывать при наведении курсора мыши на вершину).
	</p>
	
	<h4><a name="save">Сохранение в файл</a></h4>
	Сохранить граф в файл можно с помощью соответствующего пункта меню "Файл".
	При сохранении в отдельном окне необходимо выбрать тип представления графа: матрица смежности, матрица весов или структура смежности графа.<br>
	Формат файла см. в п.Загрузка файла.
	<h4><a name="load">Загрузка из файла</a></h4>
	Загрузить граф из файла можно с помощью соответствующего пункта меню "Файл".
	При загрузке в отдельном окне необходимо выбрать тип представления графа: матрица смежности, матрица весов или структура смежности графа.<br>
	<i><b>1) Матрица смежности графа</b></i><br>
	На вход небходимо подать файл с матрицой смежности, которая представляет собой квадратную матрицу, размерности равной кол-ву вершин.
	Элементы матрицы могут быть равны:
	<br>0 - если ребра i,j не существует;
	<br>1 - если ребро i,j существует.
	Элементы строки матрицы отделяются одним пробелом.
	Строки матрицы отделяются переводом строки.<br>
	
	<i><b>2) Матрица весов графа.</b></i><br>
	На вход небходимо подать файл с матрицой весов, которая представляет собой квадратную матрицу, размерности равной кол-ву вершин.
	Элементы матрицы могут быть равны:
	<br>INF - если ребра i,j не существует;
	<br>[вес - целое число] - если ребро i,j существует.
	Элементы строки матрицы отделяются одним пробелом.
	Строки матрицы отделяются переводом строки.<br>
	
	<i><b>3) Структура смежности графа</b></i><br>
	На вход небходимо подать файл со структурой сможности, которая представляет собой структуру, количество строк в которой равно кол-ву вершин.
	<br>Порядковый номер строки - порядковый номер вершины.
	<br>В строке через пробел задаются номера вершин, которые выходят из заданной.
	<br>Строки отделяются переводом строк.
	<br>Если выходящих вершин нет, то строка пустая (перевод строки сохраняется).
	
	
	<h4><a name="ect">Дополнительные возможности</a></h4>
	Дополнительными возможностями программы являются:
	<p>
		1. <b>Алгоритм Флойда–Уоршелла</b> поиска всех кротчайших путей в графе.
		
		<p>Наиболее часто используемое название, метод получил в честь двух американских исследователей Роберта Флойда и Стивена Уоршелла, одновременно открывших его в 1962 году. Реже встречаются другие варианты наименований: алгоритм Рой – Уоршелла или алгоритм Рой – Флойда. Рой – фамилия профессора, который разработал аналогичный алгоритм на 3 года раньше коллег (в 1959 г.), но это его открытие осталось безвестным. Алгоритм Флойда – Уоршелла – динамический алгоритм вычисления значений кратчайших путей для каждой из вершин графа. Метод работает на взвешенных графах, с положительными и отрицательными весами ребер, но без отрицательных циклов, являясь, таким образом, более общим в сравнении с алгоритмом Дейкстры, т. к. последний не работает с отрицательными весами ребер, и к тому же классическая его реализация подразумевает определение оптимальных расстояний от одной вершины до всех остальных.</p>
<p>Для реализации алгоритма Флойда – Уоршелла сформируем матрицу смежности D[][] графа G=(V, E), в котором каждая вершина пронумерована от 1 до |V|. Эта матрица имеет размер |V|?|V|, и каждому ее элементу D[i][j] присвоен вес ребра, идущего из вершины i в вершину j. По мере выполнения алгоритма, данная матрица будет перезаписываться: в каждую из ее ячеек внесется значение, определяющее оптимальную длину пути из вершины i в вершину j (отказ от выделения специального массива для этой цели сохранит память и время). Теперь, перед составлением основной части алгоритма, необходимо разобраться с содержанием матрицы кратчайших путей. Поскольку каждый ее элемент D[i][j] должен содержать наименьший из имеющихся маршрутов, то сразу можно сказать, что для единичной вершины он равен нулю, даже если она имеет петлю (отрицательные циклы не рассматриваются), следовательно, все элементы главной диагонали (D[i][i]) нужно обнулить. А чтобы нулевые недиагональные элементы (матрица смежности могла иметь нули в тех местах, где нет непосредственного ребра между вершинами i и j) сменили по возможности свое значение, определим их равными бесконечности, которая в программе может являться, например, максимально возможной длинной пути в графе, либо просто – большим числом.</p>
<p>Ключевая часть алгоритма, состоя из трех циклов, выражения и условного оператора, записывается довольно компактно:</p>
<p style="padding-left: 30px;">Для k от 1 до |V| выполнять<br />
Для i от 1 до |V| выполнять<br />
Для j от 1 до |V| выполнять<br />
Если D[i][k]+D[k][j]&lt;D[i][j] то D[i][j] <D[i][k]+D[k][j]</p>
<p>Кратчайший путь из вершины i в вершину j может проходить, как только через них самих, так и через множество других вершин k?(1, …, |V|). Оптимальным из i в j будет путь или не проходящий через k, или проходящий. Заключить о наличии второго случая, значит установить, что такой путь идет из i до k, а затем из k до j, поэтому должно заменить, значение кратчайшего пути D[i][j] суммой D[i][k]+D[k][j].</p>

<h5>Пример использования алгоритма Флойда–Уоршелла</h5>

<p>Положим, что в качестве матрицы смежности, каждый элемент которой хранит вес некоторого ребра, была задана следующая матрица:</p>
<p>&nbsp;</p>
<div align="center">
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top">0</td>
<td valign="top">9</td>
<td valign="top">2</td>
</tr>
<tr>
<td valign="top">1</td>
<td valign="top">0</td>
<td valign="top">4</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">4</td>
<td valign="top">0</td>
</tr>
</tbody>
</table>
</div>
<p>Количество вершин в графе, представлением которого является данная матрица, равно 3, и, причем между каждыми двумя вершинами существует ребро. Вот собственно сам этот граф:</p>
<img src="floyd_uorshell.jpg"> <img>

<p>Задача алгоритма: перезаписать данную матрицу так, чтобы каждая ячейка вместо веса ребра из i в j, содержала кратчайший путь из i в j. Для примера взят совсем маленький граф, и поэтому не будет не чего удивительного, если матрица сохранит свое изначальное состояние. Но результат тестирования программы показывает замену двух значений в ней. Следующая схема поможет с анализом этого конкретного примера.</p>
<img src="Floyd-Warshall-algorithm.png"> <img>

<p>В данной таблице показаны 27 шагов выполнения основной части алгоритма. Их столько по той причине, что время выполнения метода равно O(|V|3). Наш граф имеет 3 вершины, а 33=27. Первая замена происходит на итерации, при которой k=1, i=2, а j=3. В тот момент D[2][1]=1, D[1][3]=2, D[2][3]=4. Условие истинно, т. е. D[1][3]+D[3][2]=3, а 3<4, следовательно, элемент матрицы D[2][3] получает новое значение. Следующий шаг, когда условие также истинно привносит изменения в элемент, расположенный на пересечении второй строки и третьего столбца.</p>
<p>В данной программе при запуске алгоритма, на поле графа появляются кнопки Назад, Далее и Отмена. Эти кнопки служат для переключения демонстрации кротчайших путей(Назад и Далее) и выхода из режима показа кротчайший путей (Кнопка Отмена).
Таким образом, пути демонстрируются по очереди (при перелючении пользователем). Справа отображается текущий путь, сколько путей всего и длина пути.
</p>


</body>
</html>
